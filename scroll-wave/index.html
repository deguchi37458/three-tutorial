<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <link rel="stylesheet" href="/scroll-wave/assets/styles/index.css">
  <script src="/scroll-wave/assets/scripts/index.js" defer></script>
</head>
<body>
  <div class="webgl-canvas">
    <canvas id="webgl-canvas" class="webgl-canvas__body"></canvas>
  </div>
  <script id="v-shader" type="x-shader/x-vertex">
    varying vec2 vUv;
    uniform float uTime;
    
    float PI = 3.1415926535897932384626433832795;
    
    void main(){
      vUv = uv;
      vec3 pos = position;
    
      float offset = 0.01; // y座標に比例して値をずらすが、そのままだとかなり値が大きいので調整するための係数
      float freq = 0.05; // 振動数（の役割）。大きくすると波が細かくなる
      float amp = 10.0; // 振幅（の役割）。大きくすると波が大きくなる
      pos.x = pos.x + sin(pos.y * offset + uTime * freq * PI ) * amp;
    
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
    </script>
    <script id="f-shader" type="x-shader/x-fragment">
    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform float uImageAspect;
    uniform float uPlaneAspect;
    
    void main(){
      // 画像のアスペクトとプレーンのアスペクトを比較し、短い方に合わせる
      vec2 ratio = vec2(
        min(uPlaneAspect / uImageAspect, 1.0),
        min((1.0 / uPlaneAspect) / (1.0 / uImageAspect), 1.0)
      );
    
      // 計算結果を用いて補正後のuv値を生成
      vec2 fixedUv = vec2(
        (vUv.x - 0.5) * ratio.x + 0.5,
        (vUv.y - 0.5) * ratio.y + 0.5
      );
    
      vec3 texture = texture2D(uTexture, fixedUv).rgb;
      gl_FragColor = vec4(texture, 1.0);
    }
    </script>
</body>
</html>
